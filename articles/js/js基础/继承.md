# 继承

## 原型链继承

通过直接改变 子例 的 prototype ，来实现。  
缺点： 但是此方法会导致**引用类型**的属性被所有实例共享

```js
function Parent() {
  this.name = 'kevin';
  this.names = ['kevin', 'daisy'];
}

Parent.prototype.getName = function () {
  console.log(this.name);
};

function Child() {}

Child.prototype = new Parent();

var child1 = new Child();
console.log(child1.getName()); // kevin

child1.names.push('yayu');

var child2 = new Child();
console.log(child2.names); // ['kevin', 'daisy', 'yayu]
```

## 借用构造函数(经典继承)

优点：
父类的属性能被子类继承，且不会被所有子类共用，还可传参数
缺点：

- 父类的原型对象方法不能被使用
- 方法都在构造函数中定义，每次创建实例都会创建一遍方法。

```js
function Parent() {
  this.names = ['kevin', 'daisy'];
}
Parent.prototype.getName = function () {
  console.log(this.names);
};
function Child() {
  // 这里继承 属性
  Parent.call(this);
}

var child1 = new Child();

child1.names.push('yayu');

console.log(child1.names); // ["kevin", "daisy", "yayu"]

var child2 = new Child();

console.log(child2.names); // ["kevin", "daisy"]

child2.getName(); //child2.getName is not a function
```

## 组合继承

原型继承和构造函数继承的组合。  
使用原型链实现对原型属性和方法的继承，通过借用构造函数来实现对实例属性的继承，既通过在原型上定义方法来实现了函数复用，又保证了每个实例都有自己的属性。  

缺点：调用了2次父类的构造函数，代码也有点散
```js
function Parent(name) {
  this.name = name;
  this.colors = ['red', 'blue', 'green'];
}

Parent.prototype.getName = function () {
  console.log(this.name);
};

function Child(name, age) {
  Parent.call(this, name);
  this.age = age;
}

Child.prototype = new Parent();
Child.prototype.constructor = Child;
```
