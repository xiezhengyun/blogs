# js 浮点精度丢失

`0.1 + 0.2 !== 0.3` , 要说明白这个问题，得从一下几个角度出发。先抛出结论

> 两次存储时的精度丢失加上一次运算时的精度丢失，最终导致了 0.1 + 0.2 !== 0.3
> 0.1 转成 2 进制存下来就丢失精度一次
> 浮点数运算 0.1+0.2 也丢失一次
> 结果存下来，丢失一次

## 数字类型

ECMAScript 中的 Number 类型使用 IEEE754 标准来表示整数和浮点数值。规定了四种表示浮点数值的方式：单精确度（32 位）、双精确度（64 位）、延伸单精确度、与延伸双精确度。

ECMAScript 采用的就是双精确度，也就是说，会用 64 (Bits)位来储存一个浮点数

```
1B(Byte 字节)=8bit
1KB (Kilobyte 千字节)=1024B，
1MB (Megabyte 兆字节 简称“兆”)=1024KB，
1GB (Gigabyte 吉字节 又称“千兆”)=1024MB 后面都是1024
```

## 浮点数转 2 进制

0.75 用二进制表示

> 0.75 = a _ 2^-1 + b _ 2^-2 + c _ 2^-3 + d _ 2^-4 + ...

那怎么算出 abcd…… 的值呢，我们可以两边不停的乘以 2 算出来，解法如下：

> 0.75 = a _ 2^-1 + b _ 2^-2 + c _ 2^-3 + d _ 2^-4...

两边同时乘以 2

> 1 + 0.5 = a _ 2^0 + b _ 2^-1 + c _ 2^-2 + d _ 2^-3... (所以 a = 1)

剩下的：

> 0.5 = b _ 2^-1 + c _ 2^-2 + d \* 2^-3...

再同时乘以 2

> 1 + 0 = b _ 2^0 + c _ 2^-2 + d \* 2^-3... (所以 b = 1)

所以 0.75 用二进制表示就是 0.ab，也就是 0.11

```
现在看下0.1
0.1 = a * 2^-1 + b * 2^-2 + c * 2^-3 + d * 2^-4 + ...
0 + 0.2 = a * 2^0 + b * 2^-1 + c * 2^-2 + ...   (a = 0)
0 + 0.4 = b * 2^0 + c * 2^-1 + d * 2^-2 + ...   (b = 0)
0 + 0.8 = c * 2^0 + d * 2^-1 + e * 2^-2 + ...   (c = 0)
1 + 0.6 = d * 2^0 + e * 2^-1 + f * 2^-2 + ...   (d = 1)
1 + 0.2 = e * 2^0 + f * 2^-1 + g * 2^-2 + ...   (e = 1)
0 + 0.4 = f * 2^0 + g * 2^-1 + h * 2^-2 + ...   (f = 0)
0 + 0.8 = g * 2^0 + h * 2^-1 + i * 2^-2 + ...   (g = 0)
1 + 0.6 = h * 2^0 + i * 2^-1 + j * 2^-2 + ...   (h = 1)
```

这个计算在不停的循环，所以 0.1 用二进制表示就是 0.00011001100110011……

## 浮点数的存储

js 用 64 位存一个浮点数，但是 0.1 转成二进制是无限循环小数，所以必然会丢失精度。根据标准浮点数是这么存储:

> Value = sign _ exponent _ fraction
> -1020 -1 _ 10^3 _ 1.02 sign 就是 -1，exponent 就是 10^3，fraction 就是 1.02
> 对于二进制也是一样，以 0.1 的二进制 0.00011001100110011…… 这个数来说：
> 1 _ 2^-4 _ 1.1001100110011……

![](https://images.weserv.nl/?url=https://article.biliimg.com/bfs/article/a2f7a9da68f56a9ef307c4db959f3c210a30e3f9.jpg)

在这个标准下：

我们会用 1 位存储 S，0 表示正数，1 表示负数。

用 11 位存储 E + bias，对于 11 位来说，bias 的值是 2^(11-1) - 1，也就是 1023。

用 52 位存储 Fraction。

就拿 0.1 来看，对应二进制是 1 * 1.1001100110011…… * 2^-4， Sign 是 0，E + bias 是 -4 + 1023 = 1019，1019 用二进制表示是 1111111011，Fraction 是 1001100110011……

对应 64 位的完整表示就是：

> 0 01111111011 1001100110011001100110011001100110011001100110011010

所以当 0.1 存下来的时候，就已经发生了精度丢失，当我们用浮点数进行运算的时候，使用的其实是精度丢失后的数。

## 浮点数的运算
关于浮点数的运算，一般由以下五个步骤完成：对阶、尾数运算、规格化、舍入处理、溢出判断。我们来简单看一下 0.1 和 0.2 的计算

首先是对阶，所谓对阶，就是把阶码调整为相同，比如 0.1 是 1.1001100110011…… * 2^-4，阶码是 -4，而 0.2 就是 1.10011001100110...* 2^-3，阶码是 -3，两个阶码不同，所以先调整为相同的阶码再进行计算，调整原则是小阶对大阶，也就是 0.1 的 -4 调整为 -3，对应变成 0.11001100110011…… * 2^-3

接下来是尾数计算:
```
  0.1100110011001100110011001100110011001100110011001101
+ 1.1001100110011001100110011001100110011001100110011010
————————————————————————————————————————————————————————
 10.0110011001100110011001100110011001100110011001100111

```
我们得到结果为 10.0110011001100110011001100110011001100110011001100111 * 2^-3

将这个结果处理一下，即结果规格化，变成 1.0011001100110011001100110011001100110011001100110011(1) * 2^-2

括号里的 1 意思是说计算后这个 1 超出了范围，所以要被舍弃了。

再然后是舍入，四舍五入对应到二进制中，就是 0 舍 1 入，因为我们要把括号里的 1 丢了，所以这里会进一，结果变成

1.0011001100110011001100110011001100110011001100110100 * 2^-2

所以最终的结果存成 64 位就是

> 0 01111111101 0011001100110011001100110011001100110011001100110100

将它转换为10进制数就得到 0.30000000000000004440892098500626

因为两次存储时的精度丢失加上一次运算时的精度丢失，最终导致了 0.1 + 0.2 !== 0.3