# DOM 树构建

在渲染引擎内部，有一个叫**HTML 解析器（HTMLParser）**的模块，它的职责就是负责将 HTML 字节流转换为 DOM 结构。

**网络进程加载了多少数据，HTML 解析器便解析多少数据。**

渲染进程准备好之后，**网络进程和渲染进程之间会建立一个共享数据的管道**，网络进程接收到数据后就往这个管道里面放，而渲染进程则从管道的另外一端不断地读取数据，并同时将读取的数据传给 HTML 解析器

- 通过分词器将字节流转换为 Token
  ![](../../Images/浏览器/生成的Token示意图.png)
- 后续的第二个和第三个阶段是同步进行的，需要将 Token 解析为 DOM 节点，并将 DOM 节点添加到 DOM 树中。  
  HTML 解析器维护了一个 Token 栈结构，该 Token 栈主要用来计算节点之间的父子关系，在第一个阶段中生成的 Token 会被按照顺序压到这个栈中

- **JavaScript 文件的下载过程会阻塞 DOM 解析**
- **如果代码里引用了外部的 CSS 文件，那么在执行 JavaScript 之前，还需要等待 CSS 文件下载完成（包括 style 以及外部 csslink），并解析生成 CSSOM 对象之后，才能执行 JavaScript 脚本**
- **CSS 不阻塞 js 的加载，但是可能会阻塞 js 的执行**
- **js 会阻塞 dom 的生成，也就是会阻塞页面的渲染，那么 css 也有可能会阻塞页面的渲染。**

![](../../Images/浏览器/含有JavaScript文件和CSS文件页面的渲染流水线.png)

# CSSOM

cssom 作用：**第一个是提供给 JavaScript 操作样式表的能力，第二个是为布局树的合成提供基础的样式信息**

DOM 和 CSSOM 都构建好之后，渲染引擎就会**构造布局树**。布局树的结构基本上就是复制 DOM 树的结构，不同之处在于 DOM 树中那些不需要显示的元素会被过滤掉，如 display:none 属性的元素、head 标签、script 标签等。

复制好基本的布局树结构之后，渲染引擎会为对应的 DOM 元素选择对应的样式信息，这个过程就是**样式计算**。

样式计算完成之后，渲染引擎还需要计算布局树中每个元素对应的几何位置，这个过程就是**计算布局**。

通过样式计算和计算布局就完成了**最终布局树**的构建。再之后，就该进行后续的绘制操作了。

# 影响页面展示的因素以及优化策略

发起 URL 请求开始，到首次显示页面的内容，在视觉上经历的三个阶段。

1. 第一个阶段，等请求发出去之后，到提交数据阶段，这时页面展示出来的还是之前页面的内容
2. 提交数据之后渲染进程会创建一个空白页面，我们通常把这段时间称为**解析白屏**，并等待 CSS 文件和 JavaScript 文件的加载完成，生成 CSSOM 和 DOM，然后合成布局树，最后还要经过一系列的步骤准备首次渲染。
3. 等首次渲染完成之后，就开始进入完整页面的生成阶段了，然后页面会一点点被绘制出来

第二个阶段瓶颈： **下载 CSS 文件、下载 JavaScript 文件和执行 JavaScript。**

# 系统优化页面

通常一个页面有三个阶段：**加载阶段、交互阶段和关闭阶段**。

- 加载阶段，是指从发出请求到渲染出完整页面的过程，影响到这个阶段的主要因素有网络和 JavaScript 脚本。
- 交互阶段，主要是从页面加载完成到用户交互的整合过程，影响到这个阶段的主要因素是 JavaScript 脚本。
- 关闭阶段，主要是用户发出关闭指令后页面所做的一些清理操作。

## 加载阶段

并非所有的资源都会阻塞页面的首次绘制，比如图片、音频、视频等文件就不会阻塞页面的首次渲染；而 JavaScript、首次请求的 HTML 资源文件、CSS 文件是会阻塞首次渲染的，因为在构建 DOM 的过程中需要 HTML 和 JavaScript 文件，在构造渲染树的过程中需要用到 CSS 文件。

- 关键资源个数
- 关键资源大小
- 请求关键资源需要多少个 RTT（Round Trip Time）. 由于 TCP 的特性，这个数据并不是一次传输到服务端的，而是需要拆分成一个个数据包来回多次进行传输的。**RTT 就是这里的往返时延。它是网络中一个重要的性能指标，表示从发送端发送数据开始，到发送端收到来自接收端的确认，总共经历的时延。**

如果 JavaScript 代码没有 DOM 或者 CSSOM 的操作，则可以改成 sync 或者 defer 属性；同样对于 CSS，如果不是在构建页面之前加载的，则可以添加媒体取消阻止显现的标志。当 JavaScript 标签加上了 sync 或者 defer、CSSlink 属性之前加上了取消阻止显现的标志后，它们就变成了非关键资源了

## 交互阶段

- 减少 JavaScript 脚本执行时间(一种是将一次执行的函数分解为多个任务，使得每次的执行时间不要过久。
  另一种是采用 Web Workers)
- 避免强制同步布局. 强制同步布局 是指 JavaScript 强制将计算样式和布局操作提前到当前的任务中。
  **通常通过 DOM 接口执行添加元素或者删除元素等操作后，是需要重新计算样式和布局的，不过正常情况下这些操作都是在另外的任务中异步完成的，这样做是为了避免当前的任务占用太长的主线程时间**。  
  但是，操作了 dom 之后，如果又获取元素高度之类的操作，就需要重新布局，JavaScript 还需要强制让渲染引擎默认执行一次布局操作。我们把这个操作称为强制同步布局。（可以在修改 DOM 之前查询相关值）
- 避免布局抖动
  是指在一次 JavaScript 执行过程中，多次执行强制布局和抖动操作。连续操作 dom。可以用文档碎片 DocumentFragment，然后一次操作。
- 合理利用 CSS 合成动画
  合成动画是直接在合成线程上执行的，这和在主线程上执行的布局、绘制等操作不同，如果主线程被 JavaScript 或者一些布局任务占用，CSS 动画依然能继续执行。所以要尽量利用好 CSS 合成动画，如果能让 CSS 处理动画，就尽量交给 CSS 来操作。  
  如果能提前知道对某个元素执行动画操作，那就最好将其标记为**will-change**，这是告诉渲染引擎需要将该元素单独生成一个图层。
- 避免频繁的垃圾回收
  如果在一些函数中频繁创建临时对象，那么垃圾回收器也会频繁地去执行垃圾回收策略。这样当垃圾回收操作发生时，就会占用主线程，从而影响到其他任务的执行。**可以尽可能优化储存结构，尽可能避免小颗粒对象的产生。**
