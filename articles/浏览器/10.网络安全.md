# XSS 攻击

XSS 全称是 Cross Site Scripting，为了与“CSS”区分开来，故简称 XSS，翻译过来就是“跨站脚本”。XSS 攻击是指黑客往 HTML 文件中或者 DOM 中注入恶意脚本，从而在用户浏览页面时利用注入的恶意脚本对用户实施攻击的一种手段。

- 存储型 XSS 攻击

  - 首先黑客利用站点漏洞将一段恶意 JavaScript 代码提交到网站的数据库中；
  - 然后用户向网站请求包含了恶意 JavaScript 脚本的页面；
  - 当用户浏览该页面的时候，恶意脚本就会将用户的 Cookie 信息等数据上传到服务器。

- 反射型 XSS 攻击  
  通过恶意链接使用户将一段含有恶意代码的请求提交给 Web 服务器，Web 服务器接收到请求时，又将恶意代码反射给了浏览器端，这就是反射型 XSS 攻击。（不会存储）

- 基于 DOM 的 XSS 攻击  
  DOM 的 XSS 攻击是不牵涉到页面 Web 服务器的。具体来讲，黑客通过各种手段将恶意脚本注入用户的页面中，比如通过网络劫持在页面传输过程中修改 HTML 页面的内容，这种劫持类型很多，有通过 WiFi 路由器劫持的，有通过本地恶意软件来劫持的，它们的共同点是在 Web 资源传输过程或者在用户使用页面的过程中修改 Web 页面的数据。

## 阻止 XSS 攻击的策略

- 服务器对输入脚本进行过滤或转码
- 充分利用 **CSP**
  - 限制加载其他域下的资源文件，这样即使黑客插入了一个 JavaScript 文件，这个 JavaScript 文件也是无法被加载的；
  - 禁止向第三方域提交数据，这样用户数据也不会外泄；
  - 禁止执行内联脚本和未授权的脚本；
  - 还提供了上报机制，这样可以帮助我们尽快发现有哪些 XSS 攻击，以便尽快修复问题。
- **使用 HttpOnly 属性** JavaScript 无法读取设置了 HttpOnly 的 Cookie 数据

# CSRF 攻击

CSRF 英文全称是 Cross-site request forgery，所以又称为“跨站请求伪造”，是指黑客引诱用户打开黑客的网站，在黑客的网站中，利用用户的登录状态发起的跨站请求。简单来讲，**CSRF 攻击就是黑客利用了用户的登录状态，并通过第三方的站点来做一些坏事**

**和 XSS 不同的是，CSRF 攻击不需要将恶意代码注入用户的页面，仅仅是利用服务器的漏洞和用户的登录状态来实施攻击**

## 防御 CSRF

## cookie 的 SameSite 属性

SameSite 选项通常有 Strict、Lax 和 None 三个值。

- Strict  
  Strict 最为严格。如果 SameSite 的值是 Strict，那么浏览器会完全禁止第三方 Cookie。简言之，如果你从极客时间的页面中访问 InfoQ 的资源，而 InfoQ 的某些 Cookie 设置了 SameSite = Strict 的话，那么这些 Cookie 是不会被发送到 InfoQ 的服务器上的。只有你从 InfoQ 的站点去请求 InfoQ 的资源时，才会带上这些 Cookie。
- Lax  
  Lax 相对宽松一点。在跨站点的情况下，从第三方站点的链接打开和从第三方站点提交 Get 方式的表单这两种方式都会携带 Cookie。但如果在第三方站点中使用 Post 方法，或者通过 img、iframe 等标签加载的 URL，这些场景都不会携带 Cookie。
- None  
  而如果使用 None 的话，在任何情况下都会发送 Cookie 数据。

## 验证请求的来源站点

HTTP 请求头中的 Referer 和 Origin 属性。  
**Referer 是 HTTP 请求头中的一个字段，记录了该 HTTP 请求的来源地址**
**Origin 属性只包含了域名信息，并没有包含具体的 URL 路径，这是 Origin 和 Referer 的一个主要区别。在这里需要补充一点，Origin 的值之所以不包含详细路径信息，是有些站点因为安全考虑，不想把源站点的详细路径暴露给服务器。**

## CSRF Token

- 浏览器向服务器请求时，服务器会生成一个 CSRF Token（基本是字符串），然后将 token 植入到返回的页面中。
- 浏览器执行其他操作，需要带上 Token。如果是从第三方站点发出的请求，那么将无法获取到 CSRF Token 的值，所以即使发出了请求，服务器也会因为 CSRF Token 不正确而拒绝请求。

# 总结

页面安全问题的主要原因就是浏览器为同源策略开的两个“后门”：**一个是在页面中可以任意引用第三方资源**，**另外一个是通过 CORS 策略让 XMLHttpRequest 和 Fetch 去跨域请求资源**。

为了解决这些问题，我们引入了 CSP 来限制页面任意引入外部资源，引入了 HttpOnly 机制来禁止 XMLHttpRequest 或者 Fetch 发送一些关键 Cookie，引入了 SameSite 和 Origin 来防止 CSRF 攻击。
