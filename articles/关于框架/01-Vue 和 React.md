# Vue 和 React

首先从表象上来看一下：

- Vue template 对比 JSX

  解决一个问题的不同思路，但是基于模板的编译加上更精细的数据侦测就很有说道

- Vue 和 React 实现复用
  Vue 和 React 都是经历了：Mixin -> Hoc（Vue 比较少用，模版套模版，有点奇怪了）-> render prop（Vue 有类似思想的实现为 slot） -> hooks（Vue3.0 composition api ）

  在组合方面，UI 层复用不是个问题，因为 Vue 和 React 都是组件化的。重要的是逻辑复用，现在都到了 hooks（Vue3 composition api）

## diff 相关
### Vue

- 在内存中构建虚拟dom树
- 将内存中虚拟dom树渲染成真实dom结构
- 数据改变的时候，将之前的虚拟dom树结合新的数据生成新的虚拟dom树
- 将此次生成好的虚拟dom树和上一次的虚拟dom树进行一次比对（diff算法进行比对），来更新只需要被替换的DOM，而不是全部重绘。在Diff算法中，只平层的比较前后两棵DOM树的节点，没有进行深度的遍历。
- 会将对比出来的差异进行重新渲染

### React
React中diff算法实现流程
- DOM结构发生改变-----直接卸载并重新create
- DOM结构一样-----不会卸载,但是会update变化的内容
- 所有同一层级的子节点.他们都可以通过key来区分-----同时遵循1.2两点（其实这个key的存在与否只会影响diff算法的复杂度,换言之,你不加key的情况下,diff算法就会以暴力的方式去根据一二的策略更新,但是你加了key,diff算法会引入一些另外的操作）React会逐个对节点进行更新，转换到目标节点。而最后插入新的节点，涉及到的DOM操作非常多。

diff总共就是移动、删除、增加三个操作，而如果给每个节点唯一的标识（key），那么React优先采用移动的方式，能够找到正确的位置去插入新的节点。vue会跟踪每一个组件的依赖关系，不需要重新渲染整个组件树。而对于React而言,每当应用的状态被改变时,全部组件都会重新渲染,所以React中会需要shouldComponentUpdate这个生命周期函数方法来进行控制


## 更深入的思考

## React 和 Vue 在理念上的差别：

- `Vue` 进行数据拦截/代理，它对侦测数据的变化更敏感、更精确，也间接对一些后续实现（比如 `hooks，function based API`）提供了很大的便利
- `React` 推崇函数式，它直接进行局部重新刷新（或者重新渲染），这样更粗暴，但是更简单。( `React.createElement 调用已生成 virtual dom`)
  - 但是 `React` 并不知道什么时候“应该去刷新”，触发局部重新变化是由开发者手动调用 `setState` 完成。有时候会重复渲染，心智负担较高
  - `React` 为了弥补不必要的更新，会对 `setState` 的行为进行合并操作。因此 `setState` 有时候会是异步更新，但并不是总是“异步”

正是由于这个差别, 对于Hooks （composition api），带来了很大的区别： 

> React hook 底层是基于链表（Array）实现，每次组件被 render 的时候都会顺序执行所有的 hooks，因为底层是链表，每一个 hook 的 next 是指向下一个 hook 的，所以要求开发者不能在不同 hooks 调用中使用判断条件，因为 if 会导致顺序不正确，从而导致报错。


>Vue hook 只会被注册调用一次，Vue 之所以能避开这些麻烦的问题，根本原因在于它对数据的响应是基于响应式的，是对数据进行了代理的。他不需要链表进行 hooks 记录，它对数据直接代理观察。

Vue 这种响应式的方案，也有自己的困扰： 在 JavaScript 中，原始值类型如 string 和 number 是只有值，没有引用的。不管是使用 Object.defineProperty 还是 Proxy，我们无法追踪原始变量后续的变化

因此 Vue 不得不返回一个包装对象，不然对于基本类型，它无法做到数据的代理和拦截。这算是因为设计理念带来的一个非常非常微小的 side effect。

## 事件系统
- React 事件系统庞大而复杂。其中，它暴漏给开发者的事件不是原生事件，是 React 包装过合成事件，并且非常重要的一点是，合成事件是池化的。也就是说不同的事件，可能会共享一个合成事件对象。另外一个细节是，React 对所有事件都进行了代理，将所有事件都绑定 document 上。
- Vue 的事件系统，清晰易懂。   

**从事件 API 上我们就能看出前端框架在设计的一个不同思路： React 设计是改变开发者，提供强大而复杂的机制，开发者按照我的来；Vue 是适应开发者，让开发者怎么爽怎么来。**

## 预编译优化问题
这个问题，其实在一开始的 `template`中有一点苗头。

**Vue 之所以能够做到动静结合的 DOM diff，或者把这个问题放的更大：之所以能够做到预编译优化，是因为 Vue core 可以静态分析 template，在解析模版时，整个 parse 的过程是利用正则表达式顺序解析模板，当解析到开始标签、闭合标签、文本的时候都会分别执行对应的回调函数，来达到构造 AST 树的目的。**

Vue 需要做数据双向绑定，需要进行数据拦截或代理，那它就需要在预编译阶段静态分析模版，分析出视图依赖了哪些数据，进行响应式处理。

React 就是局部重新渲染，React 拿到的或者说掌管的，所负责的就是一堆递归 React.createElement 的执行调用，它无法从模版层面进行静态分析。

因此 React JSX 过度的灵活性导致运行时可以用于优化的信息不足。

但是, **在 React 框架之外，我们作为开发者还是可以通过工程化手段达到类似的目的**, 因为我们能够接触到 JSX 编译成 React.createElement 的整个过程。开发者在项目中开发 babel 插件，实现 JSX 编译成 React.createElement，那么优化手段就是是从编写 babel 插件开始

React 并不是没有意识到这个问题，他们在积极的同 **prepack** 合作。力求弥补构建优化的先天不足。
