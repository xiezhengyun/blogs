## diff 优化点

从 O(n^3) 到 O(n) 的大前提:

- 若两个组件属于同⼀个类型，那么它们将拥有相同的 DOM 树形结构；
- 处于同⼀层级的⼀组⼦节点，可⽤通过设置 key 作为唯⼀标识，从⽽维持各个节点在不同渲染过程 中的稳定性。

Diff 逻辑的拆分与解读:

- Diff 算法性能突破的关键点在于“分层对⽐”；(分层递归) ( 改变时间复杂度量级的决定性思路)
- 类型⼀致的节点才有继续 Diff 的必要性；
- key 属性的设置，可以帮我们尽可能重⽤同⼀层级内的节点。

## React 16 Fiber 架构

上述 diff 算法虽然足够先进，但是 却是是一条不能中断的路，由于浏览器一帧（16.6ms）, 当 JS 执行时间过长，超出了 16.6ms，这次刷新就没有时间执行样式布局和样式绘制了，Stack Reconciler 需要的调和时间会很⻓，这就意味着 JavaScript 线程将⻓时间地霸占主线 程，进⽽导致我们上⽂中所描述的渲染卡顿/卡死、交互⻓时间⽆响应等问题。 所以 Fiber 架构 因运而生。


Fiber 架构的应⽤⽬的，按照 React 官⽅的说法，是实现“增量渲染”。所谓“增量渲染”，通俗来说就 是把⼀个渲染任务分解为多个渲染任务，⽽后将其分散到多个帧⾥⾯。不过严格来说，增量渲染其实 也只是⼀种⼿段，实现增量渲染的⽬的，是为了实现任务的可中断、可恢复，并给不同的任务赋予不 同的优先级，最终达成更加顺滑的⽤户体验。

![](../../../Images/react/Fiber.png)

在这套架构模式下，更新的处理⼯作流变成了这样：⾸先，每个更新任务都会被赋予⼀个优先级。当 更新任务抵达调度器时，⾼优先级的更新任务（记为 A）会更快地被调度进 Reconciler 层；此时若有 新的更新任务（记为 B）抵达调度器，调度器会检查它的优先级，若发现 B 的优先级⾼于当前任务 A，那么当前处于 Reconciler 层的 A 任务就会被中断，调度器会将 B 任务推⼊ Reconciler 层。当 B 任务完成渲染后，新⼀轮的调度开始，之前被中断的 A 任务将会被重新推⼊ Reconciler 层，继续它 的渲染之旅，这便是所谓“可恢复”