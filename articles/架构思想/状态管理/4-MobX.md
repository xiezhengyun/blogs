# Mobx

前面说的，Flux，Redux，Vuex 其实都可以算是 Flux 体系的，单向数据流。只能统一修改 state。

MobX 背后的哲学很简单：**任何源自应用状态的东西都应该自动地获得。**

状态管理的目的：统一维护公共的应用状态，以统一并且可控的方式更新状态，状态更新后，View 跟着更新。

MobX 更接近于面向对象编程，它把 state 包装成可观察的对象，这个对象会驱动各种改变。（简直就是 Vue）

```js
const obj = observable({
  a: 1,
  b: 2,
});

autoRun(() => {
  console.log(obj.a);
});

obj.b = 3; // 什么都没有发生
obj.a = 2; // observe 函数的回调触发了，控制台输出：2
```
上面的obj，他的 obj.a 属性被使用了，那么只要 obj.a 属性一变，所有使用的地方都会被调用。autoRun 就是这个老大哥，他看着所有依赖 obj.a 的地方，也就是收集所有对 obj.a 的依赖。当 obj.a 改变时，老大哥就会触发所有依赖去更新。


- MobX 没有那么自然的数据流动，也没有时间回溯的能力，但是 View 更新很精确，粒度控制很细。
- MobX 没有中间件，副作用的处理比较自由，比如依靠 autorunAsync 之类的方法。
- MobX 代码少